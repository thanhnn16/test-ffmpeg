# CreateVideo.ps1
# Phiên bản PowerShell script tích hợp tạo video với hiệu ứng Ken Burns, xfade (smoothleft),
# kết hợp âm thanh, thêm phụ đề ASS với hiệu ứng karaoke và cleanup các file tạm.

# -------------------------------
# 1. Kiểm tra sự tồn tại của các file cần thiết
# -------------------------------

$times = @(5.42, 5.82, 4.26, 3.82, 2.98, 5.8, 4.42, 7.36)
$imgFiles = 1..8 | ForEach-Object { "$_.jpeg" }
$missingFiles = 0
Write-Host "Checking image files..."
foreach ($img in $imgFiles) {
    if (-not (Test-Path $img)) {
        Write-Error "Error: File $img not found."
        $missingFiles++
    }
}
if ($missingFiles -gt 0) {
    Write-Error "$missingFiles image files missing. Exiting."
    exit 1
}

# Kiểm tra file âm thanh
foreach ($file in @("voice.mp3", "bg.mp3")) {
    if (-not (Test-Path $file)) {
        Write-Error "Error: File $file not found."
        exit 1
    }
}

# Kiểm tra các file phụ đề và quy trình tạo ASS
$titleText = "Mèo 10 chân hút vape" # Tiêu đề mặc định, có thể thay đổi
$titleEffect = "modern" # Hiệu ứng tiêu đề: "modern", "minimal", hoặc "3d"

# Nếu cần tạo phụ đề ASS từ JSON/SRT
if ((Test-Path "whisper-transcription.json") -and (Test-Path "output.json") -and (-not (Test-Path "subtitle.ass"))) {
    Write-Host "Tạo file phụ đề ASS từ file JSON Whisper..."
    .\basic-ass-creator.ps1 "whisper-transcription.json" "output.json" "subtitle.ass"
    if (-not (Test-Path "subtitle.ass")) {
        Write-Error "Error: Không thể tạo file subtitle.ass từ các file JSON."
        exit 1
    }
    Write-Host "Tạo phụ đề ASS thành công."
}
# Kiểm tra và chuyển đổi từ SRT sang ASS nếu cần
elseif ((Test-Path "subtitle.srt") -and (-not (Test-Path "subtitle.ass"))) {
    Write-Host "Converting subtitle.srt to subtitle.ass..."
    # Tạo dòng tiêu đề trước
    $assContent = @"
[Script Info]
; Script generated by CreateVideo.ps1
Title: Beautiful ASS Subtitle
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1920
PlayResY: 1080
Timer: 100.0000
WrapStyle: 1
LineBreakStyle: 2

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,32,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,4,2,1,2,20,20,60,1
Style: Title,Arial,72,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,4,3,2,8,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"@
    # Tạo hiệu ứng tiêu đề hiện đại bằng cách tải mã từ basic-ass-creator.ps1
    . .\basic-ass-creator.ps1
    $titleLine = CreateTitleLine -style $titleEffect
    $assContent += "`n" + $titleLine
    
    # Đọc và chuyển đổi dữ liệu từ SRT
    $srtContent = Get-Content -Path "subtitle.srt" -Encoding UTF8
    $inSubtitle = $false
    $index = 0
    $start = ""
    $end = ""
    $text = ""
    
    foreach ($line in $srtContent) {
        if ([string]::IsNullOrWhiteSpace($line)) {
            if ($inSubtitle) {
                # Chuyển đổi thời gian từ SRT (00:00:00,000) sang ASS (0:00:00.00)
                # Phương pháp mới: Xử lý chuỗi thời gian trực tiếp
                $startComponents = $start -match "(\d{2}):(\d{2}):(\d{2}),(\d{3})"
                if ($startComponents) {
                    $h = [int]$Matches[1]
                    $m = $Matches[2]
                    $s = $Matches[3]
                    $ms = $Matches[4].Substring(0,2)
                    $start = "${h}:${m}:${s}.${ms}"
                }

                $endComponents = $end -match "(\d{2}):(\d{2}):(\d{2}),(\d{3})"
                if ($endComponents) {
                    $h = [int]$Matches[1]
                    $m = $Matches[2]
                    $s = $Matches[3]
                    $ms = $Matches[4].Substring(0,2)
                    $end = "${h}:${m}:${s}.${ms}"
                }
                
                # Thêm dòng phụ đề vào file ASS
                $assContent += "`nDialogue: 0,$start,$end,Default,,0,0,0,,$text"
                
                $inSubtitle = $false
                $text = ""
            }
        }
        elseif ([int]::TryParse($line, [ref]$index)) {
            $inSubtitle = $true
        }
        elseif ($inSubtitle -and $line -match "-->") {
            $timeParts = $line -split " --> "
            $start = $timeParts[0].Trim()
            $end = $timeParts[1].Trim()
        }
        elseif ($inSubtitle) {
            $text += $line.Trim() + " "
        }
    }
    
    # Thêm phụ đề cuối cùng nếu có
    if (-not [string]::IsNullOrWhiteSpace($text)) {
        # Chuyển đổi thời gian cuối cùng
        $startComponents = $start -match "(\d{2}):(\d{2}):(\d{2}),(\d{3})"
        if ($startComponents) {
            $h = [int]$Matches[1]
            $m = $Matches[2]
            $s = $Matches[3]
            $ms = $Matches[4].Substring(0,2)
            $start = "${h}:${m}:${s}.${ms}"
        }

        $endComponents = $end -match "(\d{2}):(\d{2}):(\d{2}),(\d{3})"
        if ($endComponents) {
            $h = [int]$Matches[1]
            $m = $Matches[2]
            $s = $Matches[3]
            $ms = $Matches[4].Substring(0,2)
            $end = "${h}:${m}:${s}.${ms}"
        }
        
        # Giới hạn độ dài dòng phụ đề và thêm ngắt dòng tự động
        $maxCharsPerLine = 35  # Tăng số ký tự tối đa trên mỗi dòng để tránh cắt mất nội dung
        $maxSubtitleLines = 2  # Giới hạn tối đa 2 dòng phụ đề
        $words = $text.Trim().Split(' ')
        $formattedText = ""
        $currentLine = ""
        $lineCount = 0
        
        # Tính toán tổng số ký tự và phân phối đều cho 2 dòng
        $totalChars = $text.Trim().Length
        $idealCharsPerLine = [Math]::Ceiling($totalChars / $maxSubtitleLines)
        $effectiveMaxChars = [Math]::Min($maxCharsPerLine, [Math]::Max($idealCharsPerLine, 20))
        
        # Đảm bảo luôn có 2 dòng phụ đề nếu văn bản đủ dài
        $forceNewLine = $totalChars -gt 30 -and $words.Length -gt 3
        
        # Xử lý trường hợp có từ quá dài
        $longWordThreshold = 20
        $processedWords = @()
        foreach ($word in $words) {
            if ($word.Length -gt $longWordThreshold) {
                # Chia từ dài thành các phần nhỏ hơn
                $parts = [System.Collections.ArrayList]::new()
                for ($i = 0; $i -lt $word.Length; $i += $longWordThreshold) {
                    $length = [Math]::Min($longWordThreshold, $word.Length - $i)
                    $parts.Add($word.Substring($i, $length)) | Out-Null
                }
                $processedWords += $parts
            } else {
                $processedWords += $word
            }
        }
        $words = $processedWords
        
        foreach ($word in $words) {
            # Nếu đã có đủ số dòng tối đa, thêm từ vào dòng cuối
            if ($lineCount -ge ($maxSubtitleLines - 1)) {
                if ($currentLine.Length -gt 0) {
                    $currentLine += " "
                }
                $currentLine += $word
            }
            # Nếu thêm từ này vào dòng hiện tại sẽ vượt quá giới hạn, tạo dòng mới
            elseif (($currentLine.Length + $word.Length + 1) -gt $effectiveMaxChars -or 
                   ($forceNewLine -and $lineCount -eq 0 -and $currentLine.Length -gt ($totalChars / 2))) {
                $formattedText += $currentLine
                $currentLine = $word
                $lineCount++
                
                # Thêm ký tự ngắt dòng nếu chưa đạt số dòng tối đa
                if ($lineCount -lt $maxSubtitleLines) {
                    $formattedText += "\N"
                }
            } 
            # Thêm từ vào dòng hiện tại
            else {
                if ($currentLine.Length -gt 0) {
                    $currentLine += " "
                }
                $currentLine += $word
            }
        }
        
        # Thêm dòng cuối cùng vào văn bản đã định dạng
        if ($currentLine.Length -gt 0) {
            # Nếu chưa có dòng nào, thêm trực tiếp
            if ($formattedText.Length -eq 0) {
                $formattedText = $currentLine
            }
            # Nếu đã có dòng và chưa đạt số dòng tối đa, thêm ngắt dòng
            elseif ($lineCount -lt ($maxSubtitleLines - 1)) {
                $formattedText += "\N" + $currentLine
            }
            # Nếu không, nối vào dòng cuối cùng
            else {
                $formattedText += $currentLine
            }
        }
        
        # Đảm bảo không quá 2 dòng bằng cách cắt bỏ các dòng thừa
        $lines = $formattedText.Split("\N")
        if ($lines.Count -gt $maxSubtitleLines) {
            $formattedText = $lines[0] + "\N" + $lines[1]
        }
        
        $assContent += "`nDialogue: 0,$start,$end,Default,,0,0,0,,$formattedText"
    }
    
    # Lưu file ASS
    $assContent | Out-File -FilePath "subtitle.ass" -Encoding UTF8
    if (-not (Test-Path "subtitle.ass")) {
        Write-Error "Error: Không thể chuyển đổi subtitle.srt thành subtitle.ass."
        exit 1
    }
    Write-Host "Chuyển đổi phụ đề SRT sang ASS thành công."
    
    # Đảm bảo các font thích hợp được sử dụng
    $fontCheck = $false
    # Kiểm tra nếu font tiêu đề không phải Arial
    if ((Get-Content -Path "subtitle.ass" | Select-String "Title,Arial") -eq $null) {
        Write-Host "Chuyển đổi font chữ trong ASS sang Arial để tương thích tốt hơn..."
        (Get-Content -Path "subtitle.ass") -replace "Title,[^,]+,", "Title,Arial," | Set-Content -Path "subtitle.ass"
        $fontCheck = $true
    }
    if ($fontCheck) {
        Write-Host "Đã cập nhật font chữ trong file phụ đề ASS."
    }
}
# Kiểm tra nếu không có file ASS sẵn, tạo một file mới chỉ với tiêu đề
elseif (-not (Test-Path "subtitle.ass")) {
    Write-Host "Tạo file phụ đề ASS mới chỉ với tiêu đề..."
    # Tạo dòng tiêu đề
    $assContent = @"
[Script Info]
; Script generated by CreateVideo.ps1
Title: Beautiful ASS Subtitle
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1920
PlayResY: 1080
Timer: 100.0000
WrapStyle: 1
LineBreakStyle: 2

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,32,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,4,2,1,2,20,20,60,1
Style: Title,Arial,72,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,4,3,2,8,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"@
    # Tạo hiệu ứng tiêu đề hiện đại
    . .\basic-ass-creator.ps1
    $titleLine = CreateTitleLine -style $titleEffect
    $assContent += "`n" + $titleLine
    
    # Lưu file ASS
    $assContent | Out-File -FilePath "subtitle.ass" -Encoding UTF8
    Write-Host "Tạo file phụ đề ASS mới thành công."
}

# Tạo thư mục tạm nếu chưa có
$tempDir = "temp_videos"
if (-not (Test-Path $tempDir)) {
    New-Item -ItemType Directory -Path $tempDir | Out-Null
}

# -------------------------------
# 2. Thiết lập tham số video
# -------------------------------
$videoWidth    = 512
$videoHeight   = 768
$largeScale    = 3000
$fps           = 30
$preset        = "medium"
$videoQuality  = 20
$transitionDuration = 0.5
$zoomSpeed     = 0.0008
$maxZoom       = 1.3
$bitrate       = "3M"
$gopSize       = 15

$totalDuration = ($times | Measure-Object -Sum).Sum
Write-Host "Total video duration: $totalDuration seconds."

# -------------------------------
# 3. Xử lý từng ảnh với hiệu ứng Ken Burns
# -------------------------------
for ($i = 0; $i -lt $imgFiles.Count; $i++) {
    $img   = $imgFiles[$i]
    $time  = $times[$i]
    $frames = $time * $fps
    Write-Host "Processing image $img..."
    $outputVideo = "$tempDir\$($i+1).mp4"
    switch ($i+1) {
        1 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='min(zoom+${zoomSpeed},${maxZoom})':x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
        2 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='if(eq(on,1),${maxZoom},zoom-${zoomSpeed})':x='iw-iw/zoom':y='0':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
        3 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='min(zoom+${zoomSpeed},${maxZoom})':x='0':y='ih-ih/zoom':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
        4 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='1.1':x='min(max((iw-iw/zoom)*((on)/${frames}),0),iw)':y='ih/2-(ih/zoom/2)':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
        5 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='if(eq(on,1),${maxZoom},zoom-${zoomSpeed})':x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
        6 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='1.1':x='iw/2-(iw/zoom/2)':y='min(max((ih-ih/zoom)*((on)/${frames}),0),ih)':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
        7 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='min(zoom+${zoomSpeed},${maxZoom})':x='iw-iw/zoom':y='0':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
        8 { 
            $vf = "scale=${largeScale}:-1,zoompan=z='if(eq(on,1),${maxZoom},zoom-${zoomSpeed})':x='iw-iw/zoom':y='ih-ih/zoom':d=${frames}:s=${videoWidth}x${videoHeight}:fps=${fps},setsar=1,format=yuv420p" 
        }
    }
    $ffmpegCmd = "ffmpeg -y -threads 0 -loop 1 -i $img -t $time -vf `"$vf`" -c:v libx264 -pix_fmt yuv420p -preset $preset -crf $videoQuality -r $fps -g $gopSize -keyint_min $gopSize -sc_threshold 0 -b:v $bitrate -movflags +faststart $outputVideo"
    Write-Host "Executing: $ffmpegCmd"
    Invoke-Expression $ffmpegCmd
    if (-not (Test-Path $outputVideo)) {
        Write-Error "Error: Failed to create temporary video for $img"
        exit 1
    } else {
        Write-Host "Created temporary video for $img successfully."
    }
}

# -------------------------------
# 4. Ghép các video với hiệu ứng xfade "smoothleft"
# -------------------------------

# Tạo file danh sách video để concat
$concatList = "concat_list.txt"
$concatContent = ""
for ($i = 1; $i -le 8; $i++) {
    $videoPath = "temp_videos\$i.mp4"
    if (-not (Test-Path $videoPath)) {
        Write-Error "Error: Video file $videoPath not found."
        exit 1
    }
    $concatContent += "file 'temp_videos\\$i.mp4'`n"
    if ($i -lt 8) {
        $concatContent += "duration $($times[$i-1])`n"
    }
}

# Lưu file danh sách
$concatContent | Out-File -FilePath $concatList -Encoding ASCII
if (-not (Test-Path $concatList)) {
    Write-Error "Error: Failed to create concat list file."
    exit 1
}

# Kiểm tra nội dung file danh sách
Write-Host "Concat list content:"
Get-Content $concatList | ForEach-Object { Write-Host $_ }

# Ghép video sử dụng concat filter
$ffmpegConcat = "ffmpeg -y -threads 0 -f concat -safe 0 -i $concatList -c:v libx264 -preset $preset -crf $videoQuality -r $fps -pix_fmt yuv420p -movflags +faststart final_video_no_audio.mp4"
Write-Host "Executing concat command:"
Write-Host $ffmpegConcat
Invoke-Expression $ffmpegConcat

if (-not (Test-Path "final_video_no_audio.mp4")) {
    Write-Error "Error: Failed to combine videos."
    exit 1
} else {
    Write-Host "Video combined successfully."
}

# -------------------------------
# 5. Kết hợp video với âm thanh
# -------------------------------
$filterComplexAudio = '[1:a]aresample=44100,volume=1.0[voice];[2:a]aresample=44100,volume=0.3[bg];[voice][bg]amix=inputs=2:duration=longest[a]'
$ffmpegAudio = "ffmpeg -y -threads 0 -i final_video_no_audio.mp4 -i voice.mp3 -i bg.mp3 -filter_complex `"$filterComplexAudio`" -map 0:v -map `"[a]`" -c:v copy -c:a aac -b:a 192k -shortest final_video_with_audio.mp4"
Write-Host "Executing audio merge command:"
Write-Host $ffmpegAudio
Invoke-Expression $ffmpegAudio

if (-not (Test-Path "final_video_with_audio.mp4")) {
    Write-Error "Error: Failed to merge audio with video."
    exit 1
} else {
    Write-Host "Audio merged with video successfully."
}

# -------------------------------
# 6. Thêm phụ đề ASS vào video
# -------------------------------
$ffmpegSubtitle = "ffmpeg -y -threads 0 -i final_video_with_audio.mp4 -vf `"subtitles=subtitle.ass:fontsdir=.:force_style='Fontname=Arial,FontSize=32,MarginV=60,MarginL=20,MarginR=20,Alignment=2,WrapStyle=2,LineBreakStyle=1,BorderStyle=4,Outline=2,Shadow=1,PlayResX=512,PlayResY=768'`" -c:a copy -movflags +faststart final_video.mp4"
Write-Host "Executing ASS subtitle command:"
Write-Host $ffmpegSubtitle
Invoke-Expression $ffmpegSubtitle

# Nếu cách trên không thành công, thử cách thứ hai với ass filter
if (-not (Test-Path "final_video.mp4") -or (Get-Item "final_video.mp4").Length -lt 1000) {
    Write-Host "Thử cách thứ hai để thêm phụ đề ASS..."
    $ffmpegSubtitle2 = "ffmpeg -y -threads 0 -i final_video_with_audio.mp4 -vf `"ass=subtitle.ass:fontsdir=.:force_style='FontSize=32,MarginV=60,MarginL=20,MarginR=20,Alignment=2,WrapStyle=2,LineBreakStyle=1,BorderStyle=4,Outline=2,Shadow=1,PlayResX=512,PlayResY=768'`" -c:a copy -movflags +faststart final_video.mp4"
    Write-Host "Executing second ASS subtitle command:"
    Write-Host $ffmpegSubtitle2
    Invoke-Expression $ffmpegSubtitle2
}

if (-not (Test-Path "final_video.mp4") -or (Get-Item "final_video.mp4").Length -lt 1000) {
    Write-Warning "Warning: Failed to add ASS subtitles. Copying video with audio as final output."
    Copy-Item final_video_with_audio.mp4 final_video.mp4
    if (Test-Path "final_video.mp4") {
        Write-Host "Final video (without subtitles) created."
    } else {
        Write-Error "Error: Could not create final video."
        exit 1
    }
} else {
    Write-Host "ASS subtitles added successfully."
}

Write-Host "Final video created: final_video.mp4"
Write-Host "Video dimensions: ${videoWidth}x${videoHeight}"

# -------------------------------
# 7. Cleanup các file tạm
# -------------------------------
Write-Host "Starting cleanup of temporary files..."
$tempFiles = @("final_video_no_audio.mp4", "final_video_with_audio.mp4", "simple_list.txt", "images_list.txt")
foreach ($file in $tempFiles) {
    if (Test-Path $file) {
        Remove-Item $file -Force -ErrorAction SilentlyContinue
        Write-Host "Deleted file: $file"
    }
}
if (Test-Path $tempDir) {
    Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
    Write-Host "Deleted directory: $tempDir"
}

Write-Host "Cleanup complete."
